#### 阿里巴巴实习生一面面试题

##### 读过什么源码

实际回答，建议去读SpringMVC，SpringBoot, Mybatis,Netty 其中一两个框架即可

##### 线程池有哪些参数，有哪些种类

> 参数
1. 核心线程数
2. 最大线程数
3. 线程空闲时间
4. 阻塞队列大小：queueCapacity
5. 任务拒绝处理器 ：rejectedExceptionHandler 

> 种类
1. newCachedThreadPool： 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程
2. newFixedThreadPool：创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中
3. newScheduledThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。
4. newSingleThreadExecutor：创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行
5. newSingleThreadScheduledExecutor：创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行并且可定时或者延迟执行线程活动。

##### 怎样优化MySQL

主要两方面 1. 数据库配置优化  2. SQL优化

[建议阅读]
   - [系统优化怎么做-数据库优化](https://zhuanlan.zhihu.com/p/39658503)
   - [系统优化怎么做-SQL优化](https://zhuanlan.zhihu.com/p/39736653)

##### 简述Redis各方面知识

 redis 的全称是：remote dictionary server，本质上是一个 key-value 类型的内存数据库，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。
 每秒可以处理超过 10 万次读写操作，是已知性能最快的key-value db。     
 redis多种数据结构，单个 value 的最大限 制是 512m，不像 memcached 只能保存 1mb 的数据，因此 redis 可以消息双向链表，消息队列等服务。redis 可以持久化其数据 
 另外 redis 也可以对存入的 key-value 设置 expire 时间，主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能 读写，因此 redis 适合的场景主要局限在较小数据量的高性能操作和运算上。
 redis 内部使用文件事件处理器file event handle,这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，
 将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。

##### 说一下哪些JVM内存泄漏和内存溢出场景
. 内存泄漏的场景
1. 使用静态的集合类  
   静态的集合类的生命周期和应用程序的生命周期一样长，所以在程序结束前容器中的对象不能被释放，会造成内存泄露。

> 最好不使用静态的集合类，如果使用的话，在不需要容器时要将其赋值为null。
> 修改hashset中对象的参数值，且参数是计算哈希值的字段 

2. 单例模式可能会造成内存泄露（长生命周期的对象持有短生命周期对象的引用）  
 单例模式只允许应用程序存在一个实例对象，并且这个实例对象的生命周期和应用程序的生命周期一样长，如果单例对象中拥有另一个对象的引用的话，这个被引用的对象就不能被及时回收。
> 单例对象中持有的其他对象使用弱引用，弱引用对象在GC线程工作时，其占用的内存会被回收掉。

3. 数据库、网络、输入输出流，这些资源没有显示的关闭  
  垃圾回收只负责内存回收，如果对象正在使用资源的话，Java虚拟机不能判断这些对象是不是正在进行操作，比如输入输出，也就不能回收这些对象占用的内存，
> 在资源使用完后要调用close()方法关闭。

#### 二面

##### 锁有哪些
锁的分类：

1. 公平锁/非公平锁

Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。

2. 可重入锁
可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

3. 独享锁/共享锁

对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
对于Synchronized而言，当然是独享锁。

4. 互斥锁/读写锁
互斥锁在Java中的具体实现就是ReentrantLock
读写锁在Java中的具体实现就是ReadWriteLock

5. 乐观锁/悲观锁

乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
悲观锁在Java中的使用，就是利用各种锁。
乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

6. 分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作

7. 偏向锁/轻量级锁/重量级锁
这三种锁是指锁的状态，并且是针对Synchronized。
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

8. 自旋锁
自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区

##### 多线程实现机制有哪些及其区别

两种方式：
1. 继承Thread类
2. 实现Runnable接口（Callable接口）

多线程的两种实现方式的区别：
1. Thread是Runnable接口的子类，实现Runnable接口的方式解决了Java单继承的局限
2. Runnable接口实现多线程比继承Thread类更加能描述数据共享的概念

> 由于Java单继承的局限,多线程最好是通过实现Runnable接口的方式

##### GET, POST 请求区别

HTTP协议中的两种发送请求的方法,最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。

其他区别：
1. GET在浏览器回退时是无害的，而POST会再次提交请求。
2. GET产生的URL地址可以被Bookmark，而POST不可以。
3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。
4. GET请求只能进行url编码，而POST支持多种编码方式。
5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
6. GET请求在URL中传送的参数是有长度限制的，而POST么有。
7. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

##### 如果发送302了，怎么样能拿到302后网页得信息
> 服务器返回得头部信息中会包含一个location字段，内容是重定向的URL

HTTP状态码3XX表示重定向，表明浏览器需要执行某些特殊的处理以正确处理请求

301 Moved Permanently  
永久性定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。

302 Found  
临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301相似，但302表示的资源不是永久移动，
只是临时性的。换句话说，已移动的资源对应的URI将来还有可能发生变化，比如，用户把uri保存为书签，但不会像301状态码出现时那样更新书签，而是仍旧保留返回302状态码的页面对应的uri

##### 什么是负载均衡？可以怎么实现

Load balancing，即负载均衡，是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，
以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。

硬件负载均衡性能优越，功能全面，但价格昂贵，一般适合初期或者土豪级公司长期使用。因此软件负载均衡在互联网领域大量使用。常用的软件负载均衡软件有Nginx、LVS、HaProxy等
静态负载均衡算法包括：轮询、比率、优先权。
动态负载均衡算法包括：最少连接数、最快响应速度、观察方法、预测法、动态性能分配、动态服务器补充、服务质量、服务类型、规则模式。

##### 数据库事务是什么
定义:数据库事务是构成单一逻辑工作单元的操作集合

1. 数据库事务可以包含一个或多个数据库操作,但这些操作构成一个逻辑上的整体。
2. 构成逻辑整体的这些数据库操作,要么全部执行成功,要么全部不执行。
3. 构成事务的所有操作,要么全都对数据库产生影响,要么全都不产生影响,即不管事务是否执行成功,数据库总能保持一致性状态。
4. 以上即使在数据库出现故障以及并发事务存在的情况下依然成立。

[建议阅读]
   - [数据库事务](db/transaction.md)

##### 代码： 生成一颗不对成的二叉树然后反转


- [不对成二叉树反转](https://github.com/jsong/Java-Interview/blob/master/src/main/java/com/jsong/)

##### session及cookie的区别，生命周期


1. 对于cookie  
- cookie是创建于服务器端
- cookie保存在浏览器端
- cookie的生命周期可以通过cookie.setMaxAge(2000);来设置，如果没有设置setMaxAge, 则cookie的生命周期当浏览器关闭的时候，就消亡了
- cookie可以被多个同类型的浏览器共享  可以把cookie想象成一张表


比较：

1. 存在的位置    

cookie: 存在于客户端,临时文件夹中  
session：存在于服务器的内存中，一个session域对象为一个用户浏览器服务

2. 安全性  

cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放  
session存放于服务器的内存中，所以安全性好

3. 网络传输量

cookie会传递消息给服务器  

session本身存放于服务器，不会有传送流量

4. 生命周期(以20分钟为例)

(1)cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束，

(2)session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁

但是，如果在20分钟内（如在第19分钟时）访问过session，那么，将重新计算session的生命周期

(3)关机会造成session生命周期的结束，但是对cookie没有影响

5. 访问范围

session为一个用户浏览器独享

cookie为多个用户浏览器共享

使session失效的方法：  
1. 关闭tomcat
2. reload web应用
3. session时间到
4. invalidate session


%[{ contactme.md }]%


