#### 腾讯实习生一面


##### Java的基础数据类型

整型：byte, short, int, long
字符型：char
浮点型：float, double
布尔型：boolean

##### StringBuffer和StringBuild的区别

StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。
由于 StringBuilder 相较于 StringBuffer 有速度优势。  
所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

> 一般线程安全都是加了一定的锁，速度会慢  

使用场景:  
　- String：适用于少量的字符串操作的情况  
　- StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况  
　- StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况  

##### 抽象类及接口有什么区别

接口和抽象类的区别：

1. 抽象类可以有构造方法，接口中不能有构造方法。
2. 抽象类中可以有普通成员变量，接口中没有普通成员变量
3. 抽象类中可以包含静态方法，接口中不能包含静态方法
4. 一个类可以实现多个接口，但只能继承一个抽象类。
5. 接口可以被多重实现，抽象类只能被单一继承
6. 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法

接口和抽象类的相同点：

1. 都可以被继承
2. 都不能被实例化
3. 都可以包含方法声明
4. 派生类必须实现未实现的方法

##### 方法的重写和重载
重写(Override)与重载(Overload)

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。
> 即外壳不变，核心重写！

重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

| 区别点 | 重载方法 | 重写方法 |
| :-----| ----: | :----: |
| 参数列表 | 必须修改 | 一定不能修改 |
| 返回类型 | 可以修改 | 一定不能修改 |
| 异常 | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问 | 可以修改 | 一定不能做更严格的限制（可以降低限制） |

##### Synchrolized和valotile的区别

valotile 修饰类变量、类实例时，在并发中，会及时直接写在主存中，不会拷贝副本到工作内存；禁止对有关联的语句进行重排,即有序----有可见性、有序性、无原子性；（未加这个修饰的变量修改时，会把工作区修改了，但同步至主内存不一定是实时；如果有valotile在工作区修改完，立刻同步至主内存）

synchronized 修饰类变量、类实例时，在并发中，先清空工作内存，从主存拷贝变量副本到工作内存，再从工作内存写回到主存；块内无序，块外有序-----有可见性、无有序性、原子性；

建议阅读  
[Volatile一文通](https://www.zybuluo.com/kiraSally/note/850631)  
[Synchronized一文通](https://www.zybuluo.com/kiraSally/note/857726)

##### 介绍辅助类AtmoicInteger

```SQL
public class Sample1 {
    private static Integer count = 0;
    synchronized public static void increment() {
        count++;
    }
}

public class Sample2 {
    private static AtomicInteger count = new AtomicInteger(0);
    public static void increment() {
        count.getAndIncrement();
    }
}
```
介绍
AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减。
因此十分适合高并发情况下的使用。

##### 值传递及引用传递有什么不一样
值传递：
> 形式参数类型是基本数据类型和String  

方法调用时，实际参数把它的值传递给对应的形式参数，形式参数只是用实际参数的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形式参数值的改变不影响实际参数的值。

引用传递：
> 形式参数类型是引用数据类型参数除去String  

也称为传地址。方法调用时，实际参数是对象(或数组)，这时实际参数与形式参数指向同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数。

##### SpringMVC的请求处理流程

1. 客户端发送请求到后台服务器；

2. springmvc核心控制器DispatcherServlet统一接收请求，并根据请求的url找到HandlerMapping映射的Controller;

3. Controller里面调用业务方法完成业务处理,包括与持久层交互，完成数据持久化;

4. Controller处理完业务方法后返回对应的ModelAndView(模型视图)对象，包含了返回的页面以及数据模型;

5. DispatcherServlet接收返回的ModelAndView对象，通过ViewResolver视图解析器找到对应的界面并进行页面渲染，最后页面在前端呈现出来。

##### Cookie及Session的区别

1. 对于cookie  
- cookie是创建于服务器端
- cookie保存在浏览器端
- cookie的生命周期可以通过cookie.setMaxAge(2000);来设置，如果没有设置setMaxAge, 则cookie的生命周期当浏览器关闭的时候，就消亡了
- cookie可以被多个同类型的浏览器共享  可以把cookie想象成一张表


比较：

1. 存在的位置    

cookie: 存在于客户端,临时文件夹中  
session：存在于服务器的内存中，一个session域对象为一个用户浏览器服务

2. 安全性  

cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放  
session存放于服务器的内存中，所以安全性好

3. 网络传输量

cookie会传递消息给服务器  

session本身存放于服务器，不会有传送流量

4. 生命周期(以20分钟为例)

(1)cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束，

(2)session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁

但是，如果在20分钟内（如在第19分钟时）访问过session，那么，将重新计算session的生命周期

(3)关机会造成session生命周期的结束，但是对cookie没有影响

5. 访问范围

session为一个用户浏览器独享

cookie为多个用户浏览器共享

使session失效的方法：  
1. 关闭tomcat
2. reload web应用
3. session时间到
4. invalidate session

##### Post和Get的区别

HTTP协议中的两种发送请求的方法,最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。

其他区别：
1. GET在浏览器回退时是无害的，而POST会再次提交请求。
2. GET产生的URL地址可以被Bookmark，而POST不可以。
3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。
4. GET请求只能进行url编码，而POST支持多种编码方式。
5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
6. GET请求在URL中传送的参数是有长度限制的，而POST么有。
7. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

##### Forward和重定向介绍
1. Forward转发是服务器行为，Redirect重定向是客户端行为
2. 从地址栏显示来说forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.  

redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.  

3. 从数据共享来说
forward:转发页面和转发到的页面可以共享request里面的数据.
redirect:不能共享数据.

4. 从运用地方来说
forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.

5. 从效率来说
forward:高.
redirect:低.

##### MySQL的存储引擎
查询数据库支持的存储引擎  

> show engines；

说明
 - engine：引擎名称。
 - suppot：是否支持。
 - comment：说明。
 - transactions：是够支持事务。
 - xa：是否支持XA事务。
 - savepoints：是否支持保存savepoints之间的内容。

 | 对比项 | MyISAM | InnoDB |
| :-----| ----: | :----: |
| 外键 | 不支持 | 支持 |
| 事务 | 不支持 | 支持 |
| 锁 | 表锁，对整个彪进行锁住，不适合高并发场景 | 行锁，适合高并发场景 |  
| 关注点 | 性能 | 事务 |
| 表空间 | 小 | 大 |
| 缓存 | 缓存索引，不缓存真实的对象 | 缓存索引和真实的数据，对内存的要求高 |

##### 事务的四大特性

事务具有以下4个基本特征。
- Atomic（原子性）：事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。
- Consistency（一致性）：只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。
- Isolation（隔离性）：事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。
- Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。


##### 事务的并发问题

 1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
 2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
 3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。  

> 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表 


##### 事务的隔离级别
 | 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :-----| ----: | :----: |:----: |
| 读未提交（read-uncommitted） | 是 | 是 | 是 |
| 不可重复读（read-committed）| 否 | 是 | 是 |
| 可重复读（repeatable-read） | 否 | 否|  是 |
| 串行化（serializable） | 否 | 否 | 否 |

> mysql默认的事务隔离级别为 repeatable-read
查询数据库的事务隔离: select @@tx_isolation  

设置客户端session的隔离级别: set session transaction isolation level read uncommited;

1. 事务隔离级别为读提交时，写数据只会锁住相应的行  
2. 事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。  
3. 事务隔离级别为串行化时，读写数据都会锁住整张表  
4. 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。  

##### 聚簇索引及非聚簇索引原理及区别
> 如果数据频繁的更新或删加，就不宜建立索引。

聚集索引:  
表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。  

非聚集索引:  
表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。  

> 总结一下：聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录

##### INODB都是聚簇索引吗

不是，INODB是存储引擎。索引从数据存储方式上可以分为聚簇索引和非聚簇索引（又叫二级索引）两种

##### 描述索引的加载
用索引进行查询的时候，不可能把索引全部加载到内存中，只能加载一部分其他的都要从磁盘中读取后加载到内存。  

使用B+Tree:可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的

推荐阅读：  
[Mysql索引](https://www.cnblogs.com/wangsen/p/10864136.html)

##### 索引有哪些分类
Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。  

FULLTEXT：  即为全文索引，目前只有MyISAM引擎支持。  
HASH：  可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高  
BTREE：  BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。    
RTREE：  RTREE在MySQL很少使用，仅支持geometry数据类型，。    

##### 手写冒泡排序

[代码参考](https://www.cnblogs.com/wangsen/p/10864136.html)

%[{ contactme.md }]%

